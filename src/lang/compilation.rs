#![allow(clippy::match_like_matches_macro)]
impl Default for Construction {
    fn default() -> Self {
        Self::new()
    }
}

use std::collections::HashMap;
use crate::{ lang::{ code::{ ByteCode,
                             Instruction,
                             Op },
                     source_buffer::SourceLocation,
                     tokenizing::{ Token,
                                   TokenList } },
             runtime::{ data_structures::{ dictionary::{ WordContext,
                                                         WordRuntime,
                                                         WordVisibility },
                                           value::{ ToValue,
                                                    Value } },
                        error::{ self,
                                 ScriptError },
                        interpreter::Interpreter } };



/// This struct represents a block of code being generated by the byte-cde compiler.  It can be for
/// the top level of a script, a function, or a temporary block of code that will get merged into
/// the lower, larger block of code.
#[derive(Clone)]
pub struct Construction
{
    /// If a word is being generated, this is when that word is expected to be run.
    pub runtime: WordRuntime,

    /// If a word is being generated, this is whether the word is visible in the directory listing.
    pub visibility: WordVisibility,

    /// How should the new word's context be managed?
    pub context: WordContext,


    /// The name of the word being generated.
    pub name: String,

    /// The location in the source code where the word was defined.
    pub location: SourceLocation,

    /// The description of the word being generated.
    pub description: String,

    /// The signature of the word being generated.
    pub signature: String,


    /// The byte code that is being generated.
    pub code: ByteCode
}


impl Construction
{
    /// Create a new default construction block.
    pub fn new() -> Construction
    {
        Construction
            {
                runtime: WordRuntime::Normal,
                visibility: WordVisibility::Visible,
                context: WordContext::Managed,

                name: String::new(),
                location: SourceLocation::new(),
                description: String::new(),
                signature: String::new(),

                code: ByteCode::new()
            }
    }

    /// Resolve the jump labels in the code to their relative addresses.
    pub fn resolve_jumps(&mut self)
    {
        // Is the instruction a jump instruction?
        fn is_jump(instruction: &Instruction) -> bool
        {
            match instruction.op
            {
                Op::Jump(_)          |
                Op::JumpIfZero(_)    |
                Op::JumpIfNotZero(_) |
                Op::MarkLoopExit(_)  |
                Op::MarkCatch(_)       => true,
                _                      => false
            }
        }

        // Get the string out of a Value if the value is currently holding a string.
        fn as_string(value: &Value) -> Option<String>
        {
            if value.is_string()
            {
                Some(value.get_string_val())
            }
            else
            {
                None
            }
        }

        // Get the string label from a jump instruction.
        fn jump_label(instruction: &Instruction) -> Option<String>
        {
            // We only return something if the jump instruction has a string label.  If the
            // instruction is already fixed up, we don't have anything to do.
            match &instruction.op
            {
                Op::Jump(value)          => as_string(value),
                Op::JumpIfZero(value)    => as_string(value),
                Op::JumpIfNotZero(value) => as_string(value),
                Op::MarkLoopExit(value)  => as_string(value),
                Op::MarkCatch(value)     => as_string(value),
                _                        => None
            }
        }

        // Rewrite the jump instruction's parameter to be a relative address.
        fn update_jump_op(jump_op: &Op, relative: i64) -> Op
        {
            match jump_op
            {
                Op::Jump(_)          => Op::Jump(relative.to_value()),
                Op::JumpIfZero(_)    => Op::JumpIfZero(relative.to_value()),
                Op::JumpIfNotZero(_) => Op::JumpIfNotZero(relative.to_value()),
                Op::MarkLoopExit(_)  => Op::MarkLoopExit(relative.to_value()),
                Op::MarkCatch(_)     => Op::MarkCatch(relative.to_value()),
                _                    => panic!("Invalid jump operation!")
            }
        }

        // Keep track of any labeled jump instructions we've found.
        let mut jump_indices = Vec::<i64>::new();

        // Keep track of the jump target instructions we've found and their labels.
        let mut jump_targets = HashMap::<String, i64>::new();

        // Take a first pass through the code to find all of the jump instructions and jump targets.
        for index in 0..self.code.len()
        {
            if is_jump(&self.code[index])
            {
                jump_indices.push(index as i64);
            }
            else if let Op::JumpTarget(value) = &self.code[index].op
            {
                // We found a jump target, add it to the list and remove the label from the code.
                jump_targets.insert(value.to_string(), index as i64);
                self.code[index].op = Op::JumpTarget(Value::None);
            }
        }

        // Now that we've found all of the jumps and their targets we can resolve the jumps to their
        // addresses.
        for jump_index in jump_indices
        {
            // If we found a jump with a label, we can resolve it now.
            if let Some(jump_label) = jump_label(&self.code[jump_index as usize])
            {
                // Compute the relative address of the jump target.
                let target_index = jump_targets[&jump_label];
                let relative = target_index - jump_index;

                // Update the jump instruction with the new relative address and insert it back into
                // the instruction list.
                let jump_op = &self.code[jump_index as usize].op;

                self.code[jump_index as usize].op = update_jump_op(jump_op, relative);
            }
        }
    }
}



// The list type thats used as a stack of constructions.
pub type ConstructionList = Vec<Construction>;



/// The position we are inserting code into the construction block.
pub enum InsertionLocation
{
    /// The new instructions will be inserted at the end of the code block.
    AtEnd,

    /// The new instructions will be inserted at the beginning of the code block.
    AtTop
}



/// This struct is used to manage the compiler context while generating the byte code for a script.
pub struct CodeConstructor
{
    /// The stack of code blocks being generated in this constructor.
    pub constructions: ConstructionList,

    /// The position in the code block where new instructions will be inserted.
    pub insertion: InsertionLocation,

    /// The list of tokens from the source code that is being compiled.
    pub input: TokenList,

    /// The index of the current token being processed.
    pub current: usize
}



impl CodeConstructor
{
    /// Create a new CodeConstructor context with a list of tokens to compile.  Everything else is
    /// initialized to default values.
    pub fn new(token_list: TokenList) -> CodeConstructor
    {
        CodeConstructor
            {
                constructions: vec![ Construction::new() ],
                insertion: InsertionLocation::AtEnd,
                input: token_list,
                current: 0
            }
    }

    /// Get the next token from the input list.
    pub fn next_token(&mut self) -> Option<Token>
    {
        // Make sure we haven't reached the end of the list.
        if self.current >= self.input.len()
        {
            return None;
        }

        // Get the next token and increment the current index.
        let token = &self.input[self.current];
        self.current += 1;

        Some(token.clone())
    }

    /// Crate a new code block on the top of the block stack.
    pub fn construction_new(&mut self)
    {
        self.constructions.push(Construction::new());
    }

    /// Create a new code block with a given block of byte-code.
    pub fn construction_new_with_code(&mut self, code: ByteCode)
    {
        let mut construction = Construction::new();

        construction.code = code;
        self.constructions.push(construction);
    }

    /// Pop the top code block off of the block stack, if there is one to pop.
    pub fn construction_pop(&mut self) -> error::Result<Construction>
    {
        if self.constructions.is_empty() {
            ScriptError::new_as_result(None,
                                       "No construction to pop.".to_string(),
                                       None)?;
        }

        Ok(self.constructions.pop().unwrap())
    }

    /// Get the current top code block.
    pub fn construction(&self) -> error::Result<&Construction>
    {
        if self.constructions.is_empty()
        {
            ScriptError::new_as_result(None,
                                       "Accessing an empty construction context.".to_string(),
                                       None)?;
        }

        let index = self.constructions.len() - 1;
        Ok(&self.constructions[index])
    }

    /// Get the current top code block as mutable.
    pub fn construction_mut(&mut self) -> error::Result<&mut Construction>
    {
        if self.constructions.is_empty()
        {
            ScriptError::new_as_result(None,
                                       "Accessing an empty construction context.".to_string(),
                                       None)?;
        }

        let index = self.constructions.len() - 1;
        Ok(&mut self.constructions[index])
    }

    /// Push a new instruction to the top code block.
    pub fn push_instruction(&mut self, instruction: Instruction) -> error::Result<()>
    {
        // Insert the instruction at the end or the beginning of the code block.
        if let InsertionLocation::AtEnd = self.insertion
        {
            self.construction_mut()?.code.push_back(instruction);
        }
        else
        {
            self.construction_mut()?.code.push_front(instruction);
        }

        Ok(())
    }
}



/// The list type thats used as a stack of code constructor contexts.
pub type CodeConstructorList = Vec<CodeConstructor>;



/// Process the given token and generate the appropriate byte code for it.  This function only knows
/// how to encode 3 instructions.  All other instructions are generated by immediate mode Forth
/// words.
///
/// That is why the interpreter is involved in the compilation process.  The interpreter is used to
/// find the words that know how to compile the user code offloading much of the compilation work to
/// the runtime.
pub fn process_token(interpreter: &mut dyn Interpreter,
                     token: Token)-> error::Result<()>
{
    // Convert a token into a word name.
    fn token_to_word_name(token: &Token) -> Option<( SourceLocation, String )>
    {
        match token
        {
            // Looks like a word token so we can use it as is.
            Token::Word(location, name)     => Some(( location.clone(), name.clone() )),

            // Words can also be numbers so convert the number to a string.
            Token::Number(location, number) => Some(( location.clone(), number.to_string() )),

            // Strings can't be used as word names.
            Token::String(_, _)             => None
        }
    }

    // Check to see if the token is a word that is already defined in the interpreter.
    if    let Some(( location, name )) = token_to_word_name(&token)
       && let Some(word_info) = interpreter.find_word(&name)
    {
        // We found a defined word.  If it is an immediate word, execute it now.  Otherwise generate
        // a call to the word in the byte stream.
        if let WordRuntime::Immediate = word_info.runtime
        {
            interpreter.execute_word(&location, &word_info.clone())?;
        }
        else
        {
            let index = word_info.handler_index as i64;
            let instruction = Instruction::new(Some(location), Op::Execute(index.to_value()));

            interpreter.context_mut().push_instruction(instruction)?;
        }
    }
    else
    {
        // We didn't find a defined word, so we need to generate an instruction for the token.
        match token
        {
            // The token is a word unknown to the interpreter so generate a call to it by name.
            Token::Word(location, name) =>
                {
                    let instruction = Instruction::new(Some(location),
                                                       Op::Execute(name.to_value()));

                    interpreter.context_mut().push_instruction(instruction)?;
                },

            // The token is a number so generate an instruction to push that number onto the stack
            // at runtime.
            Token::Number(location, number) =>
                {
                    let instruction = Instruction::new(Some(location),
                                                       Op::PushConstantValue(number.to_value()));

                    interpreter.context_mut().push_instruction(instruction)?;
                },

            // The token is a string so generate an instruction to push that string onto the stack
            // at runtime.
            Token::String(location, text) =>
                {
                    let instruction = Instruction::new(Some(location),
                                                       Op::PushConstantValue(text.to_value()));

                    interpreter.context_mut().push_instruction(instruction)?;
                }
        }
    }

    Ok(())
}



/// Process the given list of tokens and generate the appropriate byte-code for it.  This function
/// is the main entry point for the byte-code compiler.
///
/// At the end of the compilation process and execute the top level code of the script being
/// compiled.
pub fn process_source_from_tokens(tokens: TokenList,
                                  interpreter: &mut dyn Interpreter) -> error::Result<()>
{
    // Create a new context in the interpreter for this new token stream.
    interpreter.context_new(tokens);

    // Process each token in the token stream.  Runtime words may consume more than one token so we
    // can't expect to see every token within this loop.
    while let Some(token) = interpreter.context_mut().next_token()
    {
        // If we encounter an error while processing the current token we need to drop the code
        // generation context and return the error.
        if let Err(error) = process_token(interpreter, token)
        {
            interpreter.context_drop()?;
            return Err(error);
        }
    }

    // Attempt to extract the code from the current compilation context and then free that context.
    let code =
        {
            let construction = interpreter.context().construction();

            // There was no code to extract from the context so we can't continue.
            if let Err(error) = construction
            {
                interpreter.context_drop()?;
                return Err(error);
            }

            // Extract the code from the construction context and then drop it as it's no longer
            // needed.
            let code = construction.unwrap().code.clone();
            interpreter.context_drop()?;

            code
        };

    // Execute the script's top level code, if there is any.
    interpreter.execute_code("<toplevel>", &code)
}
